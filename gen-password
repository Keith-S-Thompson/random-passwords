#!/usr/bin/perl

# Copyright (C) 2018 Keith Thompson

# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

use File::Spec ();
use Getopt::Long ();

my $program_name = (File::Spec->splitpath($0))[2];

my %opt = ( length => 12 );
my @opts = ( \%opt, qw( length=i
                        charset=s
                        decimal!
                        hexadecimal!
                        Hexadecimal|HEXADECIMAL!
                        octal!
                        lower!
                        upper!
                        alphanumeric!
                        printable!
                        1lower!
                        1upper!
                        1decimal!
                        1punctuation!
                        1charset=s@
                        split=i
                        dev-random!
                        help!
                        debugging! ) );
$Getopt::Long::ignorecase = 0; # hexadecimal vs. -Hexadecimal
Getopt::Long::GetOptions @opts or usage();
usage() if $opt{help};
usage() if @ARGV;

$| = 1;

my $format_count = 0;
foreach my $opt (qw(charset decimal hexadecimal Hexadecimal octal
                    lower upper alphanumeric printable))
{
    $format_count ++ if defined $opt{$opt};
}

if    ($format_count == 0) { $opt{charset} = '0-9a-z' }
elsif ($format_count > 1)  { usage("Use only one charset option\n") }
elsif ($opt{decimal})      { $opt{charset} = '0-9' }
elsif ($opt{hexadecimal})  { $opt{charset} = '0-9a-f' }
elsif ($opt{Hexadecimal})  { $opt{charset} = '0-9A-F' }
elsif ($opt{octal})        { $opt{charset} = '0-7' }
elsif ($opt{lower})        { $opt{charset} = 'a-z' }
elsif ($opt{upper})        { $opt{charset} = 'A-Z' }
elsif ($opt{alphanumeric}) { $opt{charset} = 'A-Za-z0-9' }
elsif ($opt{printable})    { $opt{charset} = '!-~' }

my @valid_chars = split //, build_charset($opt{charset});

my $password = '';

for (my $i = 0; $i < $opt{length}; $i ++) {
    $password .= $valid_chars[random(scalar @valid_chars)];
}

if (defined $opt{split}) {
    my $N_chars = '.' x $opt{split};
    $password =~ s/$N_chars(?!$)/$& /g;
}

my @singletons = ();
if ($opt{'1decimal'}) {
    push @singletons, '0-9';
}
if ($opt{'1lower'}) {
    push @singletons, 'a-z';
}
if ($opt{'1upper'}) {
    push @singletons, 'A-Z';
}
if ($opt{'1punctuation'}) {
    my $set = join('', map chr, 33..126);
    $set =~ s/[0-9a-zA-Z]//g;
    push @singletons, $set;
}
if (defined $opt{'1charset'}) {
    push @singletons, @{$opt{'1charset'}};
}
die "Too many singletons\n" if scalar @singletons > length $password;
my @indices = 0 .. length($password) - 1;
foreach my $singleton (@singletons) {
    my $index = $indices[random(scalar @indices)];
    substr($password, $index, 1) = single_character($singleton);
    my $last_index = pop @indices;
    if ($index <= $#indices) {
        $indices[$index] = $last_index;
    }
}

print "$password\n";

########################################################################

#
# random($upper) returns a random number in the range 0 .. $upper-1
#
sub random {
    my($upper) = @_;
    my $buf;
    my $short_bound = 2**16;
    my $value_bound = $short_bound - ($short_bound % $upper);
    my $value;

    # Values read from the device will be in the range 0 .. $short_bound-1
    # (0..65535).  Repeat if necessary to get a value in the range
    # 0..$value_bound-1, which is computed to avoid bias; the number of possible
    # values read is a multiple of $upper.

    my $device = $opt{'dev-random'} ? '/dev/random' : '/dev/urandom';
    debug("Reading from $device\n");
    open my $RANDOM, '<', $device or die "${device}: $!\n";

    #
    # Read 2 bytes from device.
    # Discard high values to avoid bias.
    #
    do {
        my $bytes_read = read $RANDOM, $buf, 2;
        die "Failed to read from $device\n" if $bytes_read != 2;
        $value = unpack 'S', $buf;
        debugf("Read value 0x%04x\n", $value);
    } while $value >= $value_bound;

    close $RANDOM;

    my $result = $value % $upper;
    debugf("random: 0x%04x %% %d --> %d\n",
           $value, $upper, $result);
    return $result;
} # random

# ----------------------------------------------------------------------

sub expand_range {
    my($range) = @_;
    my $result;
    die "Internal error in expand_range\n" if $range !~ /^(.)-(.)$/;
    my($lo, $hi) = ($1, $2);
    die "Bad range $range\n" if ord $lo > ord $hi;
    foreach my $i (ord $lo .. ord $hi) {
        $result .= chr $i;
    }
    return $result;
} # expand_range

# ----------------------------------------------------------------------

sub build_charset {
    my($charset) = @_;
    $charset =~ s/.-./expand_range($&)/eg;
    my %result = map { $_ => 1 } split //, $charset;
    return join '', sort keys %result;
} #  build_charset

# ----------------------------------------------------------------------

sub single_character {
    my($charset) = @_;
    $charset =~ s/.-./expand_range($&)/eg;
    return substr($charset, random(length($charset)), 1);
}

# ----------------------------------------------------------------------

sub usage {
    print @_;
    print <<"EOF";
usage: $program_name [options]
    -help         Display this message and exit
    -length N     Length of generated password, default is 12
    -charset ...  Character set, default is "a-z0-9"
                  The argument is a single word.
    -decimal      Equivalent to "-charset 0-9"
    -hexadecimal  Equivalent to "-charset 0-9a-f"
    -Hexadecimal  Equivalent to "-charset 0-9A-F"
    -octal        Equivalent to "-charset 0-7"
    -lower        Equivalent to "-charset a-z"
    -upper        Equivalent to "-charset A-Z"
    -alphanumeric Equivalent to "-charset A-Za-z0-9"
    -printable    Equivalent to "-charset !-~"
                  (ASCII non-blank printable characters)
    -1lower       Include (at least) 1 lower case letter
    -1upper       Include (at least) 1 upper case letter
    -1decimal     Include (at least) 1 decimal digit
    -1punctuation Include (at least) 1 punctuation character
    -1charset ... Include (at least) 1 character from the specified set
                  This option may be given multiple times
                  (The other -1... options may only be given once)
    -split N      Split with a blank every N characters
    -dev-random   Use /dev/random rather than /dev/urandom (slow)
    -debugging    Produce debugging output
EOF
    exit 1;
} # usage

# ----------------------------------------------------------------------

sub debug {
    print @_ if $opt{debugging};
} # debug

# ----------------------------------------------------------------------

sub debugf {
    printf @_ if $opt{debugging};
} # debugf
